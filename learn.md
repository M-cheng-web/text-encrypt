# 额外记录

```'*' 和 * 是不一样的, '*' 作为参数 => $1 = (fileA fileB fileC)
* 作为参数 => $1 = fileA   $2 = fileB   $3 = fileC
```

这种方式比较的会有误差
```
比如: arr=(demo abc) file=demo2 也会匹配上
if [[ "${arr[@]}" = "$file" ]]
  then
    # 在数组内
    echo '不遍历的文件夹: '$file
  else
    # 不在数组内
fi
```

带有空格的入参,比如 'a b c',会自动可以被遍历的 (for in 遍历带空格的都可以进行遍历)

echo $(ls | grep .js) 这样能拿到当前目录所有文件,然后 grep 筛选

哪里执行的命令,就以那个位置为基准,比如创建文件的时候如果直接写文件名,是直接创建在那个位置的

传参不能手动传 *, 要传 all, 传 * 会将路径解析出来再给到脚本,这样不行


加密的几种方案
1. 对比修改时间 (这个存在很多不确定性, 否)
2. 加密后的文件内容加一些自己的内容,解密的时候 (可)
3. 加密后的文件添加自己的后缀名 (可)

注意: 不能用直接添加后缀名的方式来标明,某些场景会影响业务,应该保留文件原始后缀名

这边支持一下输入原文件名就可以判断是否为加密文件
a.js 加密后是 a.js, 那么解密就需要输入 a.encrypt.js 才可以
这边加上了就可以支持输入 a.js 就能解密